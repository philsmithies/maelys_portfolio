var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import React, { createContext, useMemo, useContext } from "react";
var ListNestMode;
(function(ListNestMode2) {
  ListNestMode2["Html"] = "html";
  ListNestMode2["Direct"] = "direct";
})(ListNestMode || (ListNestMode = {}));
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text === "string" && (Array.isArray(node.marks) || typeof node.marks === "undefined");
}
function isPortableTextBlock(node) {
  return typeof node._type === "string" && node._type[0] !== "@" && (!("markDefs" in node) || Array.isArray(node.markDefs) && node.markDefs.every((def) => typeof def._key === "string")) && "children" in node && Array.isArray(node.children) && node.children.every((child) => typeof child === "object" && "_type" in child);
}
function isListItemBlock(block) {
  return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem === "string";
}
function isToolkitList(block) {
  return block._type === "@list";
}
function isToolkitSpan(span) {
  return span._type === "@span";
}
function isToolkitTextNode(node) {
  return node._type === "@text";
}
function spanToPlainText(span) {
  let text = "";
  span.children.forEach((current) => {
    if (isToolkitTextNode(current)) {
      text += current.text;
    } else if (isToolkitSpan(current)) {
      text += spanToPlainText(current);
    }
  });
  return text;
}
function toPlainText(block) {
  const blocks = Array.isArray(block) ? block : [block];
  let text = "";
  blocks.forEach((current, index) => {
    if (!isPortableTextBlock(current)) {
      return;
    }
    current.children.forEach((span) => {
      text += isPortableTextSpan(span) ? span.text : " ";
    });
    if (index !== blocks.length - 1) {
      text += "\n\n";
    }
  });
  return text;
}
function nestLists(blocks, mode) {
  const tree = [];
  let currentList;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (!isListItemBlock(block)) {
      tree.push(block);
      currentList = void 0;
      continue;
    }
    if (!currentList) {
      currentList = listFromBlock(block, i, mode);
      tree.push(currentList);
      continue;
    }
    if (blockMatchesList(block, currentList)) {
      currentList.children.push(block);
      continue;
    }
    if ((block.level || 1) > currentList.level) {
      const newList = listFromBlock(block, i, mode);
      if (mode === "html") {
        const lastListItem = currentList.children[currentList.children.length - 1];
        const newLastChild = __spreadProps(__spreadValues({}, lastListItem), {
          children: [...lastListItem.children, newList]
        });
        currentList.children[currentList.children.length - 1] = newLastChild;
      } else {
        currentList.children.push(newList);
      }
      currentList = newList;
      continue;
    }
    if ((block.level || 1) < currentList.level) {
      const match = findListMatching(tree[tree.length - 1], block);
      if (match) {
        currentList = match;
        currentList.children.push(block);
        continue;
      }
      currentList = listFromBlock(block, i, mode);
      tree.push(currentList);
      continue;
    }
    if (block.listItem !== currentList.listItem) {
      const match = findListMatching(tree[tree.length - 1], { level: block.level || 1 });
      if (match && match.listItem === block.listItem) {
        currentList = match;
        currentList.children.push(block);
        continue;
      } else {
        currentList = listFromBlock(block, i, mode);
        tree.push(currentList);
        continue;
      }
    }
    console.warn("Unknown state encountered for block", block);
    tree.push(block);
  }
  return tree;
}
function blockMatchesList(block, list) {
  return (block.level || 1) === (list.level || 1) && (block.listItem || "bullet") === (list.listItem || "bullet");
}
function listFromBlock(block, index, mode) {
  return {
    _type: "@list",
    _key: `${block._key || `${index}`}-parent`,
    mode,
    level: block.level || 1,
    listItem: block.listItem || "bullet",
    children: [block]
  };
}
function findListMatching(rootNode, matching) {
  const level = matching.level || 1;
  const style = matching.listItem || "normal";
  const filterOnType = typeof matching.listItem === "string";
  if (isToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) {
    return rootNode;
  }
  if (!("children" in rootNode)) {
    return void 0;
  }
  const node = rootNode.children[rootNode.children.length - 1];
  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
const knownDecorators = ["strong", "em", "code", "underline", "strike-through"];
function buildMarksTree(block) {
  const { children, markDefs = [] } = block;
  if (!children || !children.length) {
    return [];
  }
  const sortedMarks = children.map(sortMarksByOccurences);
  const rootNode = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let nodeStack = [rootNode];
  for (let i = 0; i < children.length; i++) {
    const span = children[i];
    const marksNeeded = sortedMarks[i];
    if (!marksNeeded) {
      const lastNode = nodeStack[nodeStack.length - 1];
      lastNode.children.push(__spreadProps(__spreadValues({}, span), { _type: "@span", children: [], markType: "<unknown>" }));
      continue;
    }
    let pos = 1;
    if (nodeStack.length > 1) {
      for (pos; pos < nodeStack.length; pos++) {
        const mark = nodeStack[pos].markKey;
        const index = mark ? marksNeeded.indexOf(mark) : -1;
        if (index === -1) {
          break;
        }
        marksNeeded.splice(index, 1);
      }
    }
    nodeStack = nodeStack.slice(0, pos);
    let currentNode = findLastParentNode(nodeStack) || rootNode;
    for (const markKey of marksNeeded) {
      const markDef = markDefs.find((def) => def._key === markKey);
      const markType = markDef ? markDef._type : markKey;
      const node = {
        _type: "@span",
        _key: span._key,
        children: [],
        markDef,
        markType,
        markKey
      };
      currentNode.children.push(node);
      nodeStack.push(node);
      currentNode = node;
    }
    if (isPortableTextSpan(span)) {
      const lines = span.text.split("\n");
      for (let line = lines.length; line-- > 1; ) {
        lines.splice(line, 0, "\n");
      }
      currentNode.children = currentNode.children.concat(lines.map(toTextNode));
    } else {
      currentNode.children = currentNode.children.concat(span);
    }
  }
  return rootNode.children;
}
function sortMarksByOccurences(span, i, spans) {
  if (!isPortableTextSpan(span) || !span.marks) {
    return [];
  }
  if (!span.marks.length) {
    return [];
  }
  const marks = span.marks.slice();
  const occurences = {};
  marks.forEach((mark) => {
    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1;
    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {
      const sibling = spans[siblingIndex];
      if (isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {
        occurences[mark]++;
      } else {
        break;
      }
    }
  });
  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
  const aOccurences = occurences[markA] || 0;
  const bOccurences = occurences[markB] || 0;
  if (aOccurences !== bOccurences) {
    return bOccurences - aOccurences;
  }
  const aKnownPos = knownDecorators.indexOf(markA);
  const bKnownPos = knownDecorators.indexOf(markB);
  if (aKnownPos !== bKnownPos) {
    return aKnownPos - bKnownPos;
  }
  if (markA < markB) {
    return -1;
  } else if (markA > markB) {
    return 1;
  }
  return 0;
}
function findLastParentNode(nodes) {
  for (let i = nodes.length - 1; i >= 0; i--) {
    const node = nodes[i];
    if (node._type === "@span" && node.children) {
      return node;
    }
  }
  return void 0;
}
function toTextNode(text) {
  return { _type: "@text", text };
}
function mergeComponents(parent, overrides) {
  const _a = overrides, { block, list, listItem, marks, types } = _a, rest = __objRest(_a, ["block", "list", "listItem", "marks", "types"]);
  return __spreadValues(__spreadProps(__spreadValues({}, parent), {
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types")
  }), rest);
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key];
  const parentVal = parent[key];
  if (typeof override === "function") {
    return override;
  }
  if (override && typeof parentVal === "function") {
    return override;
  }
  if (override) {
    return __spreadValues(__spreadValues({}, parentVal), override);
  }
  return parentVal;
}
const link = ({ children, value }) => /* @__PURE__ */ React.createElement("a", {
  href: value == null ? void 0 : value.href
}, children);
const underlineStyle = { textDecoration: "underline" };
const defaultMarks = {
  em: ({ children }) => /* @__PURE__ */ React.createElement("em", null, children),
  strong: ({ children }) => /* @__PURE__ */ React.createElement("strong", null, children),
  code: ({ children }) => /* @__PURE__ */ React.createElement("code", null, children),
  underline: ({ children }) => /* @__PURE__ */ React.createElement("span", {
    style: underlineStyle
  }, children),
  "strike-through": ({ children }) => /* @__PURE__ */ React.createElement("del", null, children),
  link
};
const defaultLists = {
  number: ({ children }) => /* @__PURE__ */ React.createElement("ol", null, children),
  bullet: ({ children }) => /* @__PURE__ */ React.createElement("ul", null, children)
};
const DefaultListItem = ({ children }) => /* @__PURE__ */ React.createElement("li", null, children);
const getTemplate = (type, prop) => `Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`;
const unknownTypeWarning = (typeName) => getTemplate(`block type "${typeName}"`, "types");
const unknownMarkWarning = (markType) => getTemplate(`mark type "${markType}"`, "marks");
const unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style "${blockStyle}"`, "block");
const unknownListStyleWarning = (listStyle) => getTemplate(`list style "${listStyle}"`, "list");
const unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
  console.warn(message);
}
const hidden = { display: "none" };
const DefaultUnknownType = ({
  value,
  isInline
}) => {
  const warning = unknownTypeWarning(value._type);
  return isInline ? /* @__PURE__ */ React.createElement("span", {
    style: hidden
  }, warning) : /* @__PURE__ */ React.createElement("div", {
    style: hidden
  }, warning);
};
const DefaultUnknownMark = ({
  markType,
  children
}) => {
  return /* @__PURE__ */ React.createElement("span", {
    className: `unknown__pt__mark__${markType}`
  }, children);
};
const DefaultUnknownBlockStyle = ({
  children
}) => {
  return /* @__PURE__ */ React.createElement("p", null, children);
};
const DefaultUnknownList = ({ children }) => {
  return /* @__PURE__ */ React.createElement("ul", null, children);
};
const DefaultUnknownListItem = ({
  children
}) => {
  return /* @__PURE__ */ React.createElement("li", null, children);
};
const DefaultHardBreak = () => /* @__PURE__ */ React.createElement("br", null);
const defaultBlockStyles = {
  normal: ({ children }) => /* @__PURE__ */ React.createElement("p", null, children),
  blockquote: ({ children }) => /* @__PURE__ */ React.createElement("blockquote", null, children),
  h1: ({ children }) => /* @__PURE__ */ React.createElement("h1", null, children),
  h2: ({ children }) => /* @__PURE__ */ React.createElement("h2", null, children),
  h3: ({ children }) => /* @__PURE__ */ React.createElement("h3", null, children),
  h4: ({ children }) => /* @__PURE__ */ React.createElement("h4", null, children),
  h5: ({ children }) => /* @__PURE__ */ React.createElement("h5", null, children),
  h6: ({ children }) => /* @__PURE__ */ React.createElement("h6", null, children)
};
const defaultComponents = {
  types: {},
  block: defaultBlockStyles,
  marks: defaultMarks,
  list: defaultLists,
  listItem: DefaultListItem,
  hardBreak: DefaultHardBreak,
  unknownType: DefaultUnknownType,
  unknownMark: DefaultUnknownMark,
  unknownList: DefaultUnknownList,
  unknownListItem: DefaultUnknownListItem,
  unknownBlockStyle: DefaultUnknownBlockStyle
};
const PortableTextComponentsContext = createContext(defaultComponents);
const PortableTextComponentsProvider = ({
  components,
  children
}) => {
  const value = useMemo(() => mergeComponents(defaultComponents, components), [components]);
  return /* @__PURE__ */ React.createElement(PortableTextComponentsContext.Provider, {
    value
  }, children);
};
function PortableText({
  value: input,
  components: componentOverrides,
  listNestingMode,
  onMissingComponent: missingComponentHandler = printWarning
}) {
  const handleMissingComponent = missingComponentHandler || noop;
  const blocks = Array.isArray(input) ? input : [input];
  const nested = nestLists(blocks, listNestingMode || ListNestMode.Html);
  const parentComponents = useContext(PortableTextComponentsContext);
  const components = useMemo(() => {
    return componentOverrides ? mergeComponents(parentComponents, componentOverrides) : parentComponents;
  }, [parentComponents, componentOverrides]);
  const renderNode = useMemo(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]);
  const rendered = nested.map((node, index) => renderNode({ node, index, isInline: false, renderNode }));
  return componentOverrides ? /* @__PURE__ */ React.createElement(PortableTextComponentsContext.Provider, {
    value: components
  }, rendered) : /* @__PURE__ */ React.createElement(React.Fragment, null, rendered);
}
const getNodeRenderer = (components, handleMissingComponent) => {
  function renderNode(options) {
    const { node, index, isInline } = options;
    const key = node._key || `node-${index}`;
    if (isToolkitList(node)) {
      return renderList(node, index, key);
    }
    if (isListItemBlock(node)) {
      return renderListItem(node, index, key);
    }
    if (isToolkitSpan(node)) {
      return renderSpan(node, index, key);
    }
    if (isPortableTextBlock(node)) {
      return renderBlock(node, index, key, isInline);
    }
    if (isToolkitTextNode(node)) {
      return renderText(node, key);
    }
    return renderCustomBlock(node, index, key, isInline);
  }
  function renderListItem(node, index, key) {
    const tree = serializeBlock({ node, index, isInline: false, renderNode });
    const renderer = components.listItem;
    const handler = typeof renderer === "function" ? renderer : renderer[node.listItem];
    const Li = handler || components.unknownListItem;
    if (Li === components.unknownListItem) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListItemStyleWarning(style), {
        type: style,
        nodeType: "listItemStyle"
      });
    }
    let children = tree.children;
    if (node.style && node.style !== "normal") {
      const _a = node, { listItem } = _a, blockNode = __objRest(_a, ["listItem"]);
      children = renderNode({ node: blockNode, index, isInline: false, renderNode });
    }
    return /* @__PURE__ */ React.createElement(Li, {
      key,
      value: node,
      index,
      isInline: false,
      renderNode
    }, children);
  }
  function renderList(node, index, key) {
    const children = node.children.map((child, childIndex) => renderNode({
      node: child._key ? child : __spreadProps(__spreadValues({}, child), { _key: `li-${index}-${childIndex}` }),
      index,
      isInline: false,
      renderNode
    }));
    const component = components.list;
    const handler = typeof component === "function" ? component : component[node.listItem];
    const List = handler || components.unknownList;
    if (List === components.unknownList) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListStyleWarning(style), { nodeType: "listStyle", type: style });
    }
    return /* @__PURE__ */ React.createElement(List, {
      key,
      value: node,
      index,
      isInline: false,
      renderNode
    }, children);
  }
  function renderSpan(node, index, key) {
    const { markDef, markType, markKey } = node;
    const Span = components.marks[markType] || components.unknownMark;
    const children = node.children.map((child, childIndex) => renderNode({ node: child, index: childIndex, isInline: true, renderNode }));
    if (Span === components.unknownMark) {
      handleMissingComponent(unknownMarkWarning(markType), { nodeType: "mark", type: markType });
    }
    return /* @__PURE__ */ React.createElement(Span, {
      key,
      text: spanToPlainText(node),
      value: markDef,
      markType,
      markKey,
      renderNode
    }, children);
  }
  function renderBlock(node, index, key, isInline) {
    const _a = serializeBlock({ node, index, isInline, renderNode }), { _key } = _a, props = __objRest(_a, ["_key"]);
    const style = props.node.style || "normal";
    const handler = typeof components.block === "function" ? components.block : components.block[style];
    const Block = handler || components.unknownBlockStyle;
    if (Block === components.unknownBlockStyle) {
      handleMissingComponent(unknownBlockStyleWarning(style), {
        nodeType: "blockStyle",
        type: style
      });
    }
    return /* @__PURE__ */ React.createElement(Block, __spreadProps(__spreadValues({
      key
    }, props), {
      value: props.node,
      renderNode
    }));
  }
  function renderText(node, key) {
    if (node.text === "\n") {
      const HardBreak = components.hardBreak;
      return HardBreak ? /* @__PURE__ */ React.createElement(HardBreak, {
        key
      }) : "\n";
    }
    return node.text;
  }
  function renderCustomBlock(node, index, key, isInline) {
    const Node = components.types[node._type];
    const nodeOptions = {
      value: node,
      isInline,
      index,
      renderNode
    };
    if (Node) {
      return /* @__PURE__ */ React.createElement(Node, __spreadValues({
        key
      }, nodeOptions));
    }
    handleMissingComponent(unknownTypeWarning(node._type), { nodeType: "block", type: node._type });
    const UnknownType = components.unknownType;
    return /* @__PURE__ */ React.createElement(UnknownType, __spreadValues({
      key
    }, nodeOptions));
  }
  return renderNode;
};
function serializeBlock(options) {
  const { node, index, isInline, renderNode } = options;
  const tree = buildMarksTree(node);
  const children = tree.map((child, i) => renderNode({ node: child, isInline: true, index: i, renderNode }));
  return {
    _key: node._key || `block-${index}`,
    children,
    index,
    isInline,
    node
  };
}
function noop() {
}
export { ListNestMode, PortableText, PortableTextComponentsProvider, defaultComponents, mergeComponents, toPlainText };
//# sourceMappingURL=react-portable-text.esm.js.map
